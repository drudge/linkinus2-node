
#import "LKPlugin.h"
#import "LKPluginProtocol.h"
#import "LKPlugin+PreferencesExtensions.h"

/*
 * This is a sample plug-in project. In a real-life product, you will have to change
 * the name of this class: please use a unique class prefix and name.
 * Two plug-ins whose principal classes have the very same name will result in a
 * conflict: only one of these will be used by Linkinus.
 *
 * Do not forget to edit Info.plist accordingly!
 * If you have preference pane bundles, the bundle identifier should be the same
 * or you will have to modify the default preferences handling system.
 */
@implementation LKPlugin

/*
 * Designated initializer.
 * If your plug-in needs access to agent-related data such as the currently selected channel,
 * you might want to store the agent somewhere (a weak reference will suffice).
 */
- (id <LKPluginProtocol>)initWithAgent:(id <LKAgentProtocol>)agent
{
	if (self = [super init])
	{
		_agent = agent;
	}
	
	return self;
}

/*
 * A plug-in can do up to three tasks:
 *     - catch pre-handled incoming IRC data and respond to it
 *     - catch pre-handled outgoing IRC data and respond to it
 *     - implement new commands (new features for the end-user)
 *
 * In this example, we are just logging all incoming and outgoing information,
 * plus we add two new commands: CMD and COMMAND whose behavior the user can
 * setup in the preference pane. Please see the "Linkinus Preference Pane" project
 * to learn more about preference panes.
 */

#pragma mark -
#pragma mark Catch incoming data

/*
 * Implementing all of the methods available in the protocol (even if you leave them blank)
 * is strongly suggested because:
 *      - it will shut the compiler up
 *      - there will be no need for Linkinus to perform error-checking
 */

- (void)incomingNick:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)incomingJoin:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)incomingKick:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)incomingNotice:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)incomingPart:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)incomingQuit:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)incomingMessage:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)incomingAction:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)incomingMode:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }

#pragma mark -
#pragma mark Catch outgoing data

- (void)outgoingAway:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)outgoingMode:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)outgoingBan:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)outgoingJoin:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)outgoingKick:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)outgoingMessage:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)outgoingNotice:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)outgoingAction:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)outgoingNick:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)outgoingPart:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }
- (void)outgoingQuit:(NSDictionary *)infoDict { NSLog (@"[%@] %@", NSStringFromSelector(_cmd), infoDict); }

#pragma mark -
#pragma mark Handle new commands

/*
 * Return an array containing the mnemonics your plug-in knows how to handle.
 */
+ (NSArray *)availableCommands
{
	return [NSArray arrayWithObjects:@"command", @"cmd", nil];
}


/*
 * The user sent a command of the kind you said you supported.
 * This is where the magic happens: handle the outgoing string the way you want.
 */
- (void)handleCommand:(NSString *)line onConnection:(id <LKConnectionProtocol>)connection
{
	BOOL pluginEnabled = [self pluginEnabled];
	
	if (pluginEnabled)
	{
		unsigned i, j;
		NSArray *channels = [connection channels];
		LKSamplePluginTag tag = [self pluginSelectedTag];
		
		switch (tag)
		{
			case LKSamplePluginNewsTag:
				[[NSWorkspace sharedWorkspace] openURL:[NSURL URLWithString:@"http://www.code47.com/linkinus"]];
				break;
				
			case LKSamplePluginGreetTag:
				j = [channels count];
				for (i=0; i<j; ++i)
				{
					id <LKChannelProtocol> channelOrQueryOrConsole = [channels objectAtIndex:i];
					if (![channelOrQueryOrConsole isConsole])
					{
						[connection processCommand:[NSString stringWithFormat:@"/msg %@ Hello! How are you today?", [channelOrQueryOrConsole name]]];
					}
				}
				break;
			
			case LKSamplePluginBeautifulTag:
				[[_agent currentChannel] echo:@"You are the most beautiful person ever."];
				break;
		}
	}
}

@end